import os
import argparse
import pickle

import torch
import torch.nn.functional as F


def main():
  parser = argparse.ArgumentParser("Configuration for data preparation")
  parser.add_argument("--data_file", default="./libri-light_data/dev_unlab_600_full", type=str,
    help="Path to the librispeech log Mel features generated by the Kaldi scripts")
  parser.add_argument("--max_seq_len", default=8000, type=int,
    help="The maximum length (number of frames) of each sequence; sequences will be truncated or padded (with zero vectors) to this length")
  parser.add_argument("--save_dir", default="./libri-light_data/preprocessed/dev_unlab_600_full", type=str,
    help="Directory to save the preprocessed pytorch tensors")
  config = parser.parse_args()

  os.makedirs(config.save_dir, exist_ok=True)

  id2len = {}
  with open(config.data_file, 'r') as f:
    # process the file line by line
    for line in f:
      data = line.strip().split()

      if len(data) > 2: # other than like 1272-128104-0000  [
        if data[-1] == ']':  # end of the current utterance
          id2len[utt_id + '.pt'] = min(len(log_mel), config.max_seq_len)
          log_mel.append([float(i) for i in data[:-1]])  # the last element data[-1] is ']' so kick it out
          log_mel = torch.FloatTensor(log_mel)  # convert the 2D list to a pytorch tensor
          log_mel = F.pad(log_mel, (0, 0, 0, config.max_seq_len - log_mel.size(0))) # pad or truncate
          torch.save(log_mel, os.path.join(config.save_dir, utt_id + '.pt'))

        else: # normal line containing a frame's feature vector
          log_mel.append([float(i) for i in data])

      else: # here starts a new utterance
        # log_mel.append([float(i) for i in data])
        utt_id = data[0]
        log_mel = []
  with open(os.path.join(config.save_dir, 'lengths.pkl'), 'wb') as f:
    pickle.dump(id2len, f, protocol=4)


if __name__ == '__main__':
  main()
